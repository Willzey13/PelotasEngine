package data;

import flixel.FlxG.FlxRenderMethod;
import flixel.FlxG;
import flixel.util.FlxSignal.FlxTypedSignal;
import openfl.Lib;
import openfl.events.UncaughtErrorEvent;
import sys.io.File;

using StringTools;

/**
 * A custom crash handler that writes to a log file and displays a message box.
 */
@:nullSafety
class CrashHandler {
  public static final LOG_FOLDER = 'logs';

  public static var errorSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();
  public static var criticalErrorSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

  public static function initialize():Void {
    trace('[LOG] Enabling standard uncaught error handler...');
    Lib.current.loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, onUncaughtError);

    #if cpp
    trace('[LOG] Enabling C++ critical error handler...');
    untyped __global__.__hxcpp_set_critical_error_handler(onCriticalError);
    #end
  }

  static function onUncaughtError(error:UncaughtErrorEvent):Void {
    try {
      errorSignal.dispatch(generateErrorMessage(error));

      #if sys
      logError(error);
      #end

      displayError(error);
    } catch (e:Dynamic) {
      trace('Error while handling crash: ' + e);
    }

    #if sys
    Sys.sleep(1);
    openfl.Lib.application.window.close();
    #end
  }

  static function onCriticalError(message:String):Void {
    try {
      criticalErrorSignal.dispatch(message);

      #if sys
      logErrorMessage(message, true);
      #end

      displayErrorMessage(message);
    } catch (e:Dynamic) {
      trace('Error while handling crash: $e');
      trace('Message: $message');
    }

    #if sys
    Sys.sleep(1);
    openfl.Lib.application.window.close();
    #end
  }

  static function displayError(error:UncaughtErrorEvent):Void {
    displayErrorMessage(generateErrorMessage(error));
  }

  static function displayErrorMessage(message:String):Void {
    lime.app.Application.current.window.alert(message, "Fatal Uncaught Exception");
  }

  #if sys
  static function logError(error:UncaughtErrorEvent):Void {
    logErrorMessage(generateErrorMessage(error));
  }

  static function logErrorMessage(message:String, critical:Bool = false):Void {
    var logDir = haxe.io.Path.join([Sys.getCwd(), LOG_FOLDER]);
    if (!sys.FileSystem.exists(logDir)) {
      sys.FileSystem.createDirectory(logDir);
    }

    var safeDate = Date.now().toString().replace(":", "-").replace(":", "-").replace(" ", "_");
    var filename = haxe.io.Path.join([logDir, 'crash${critical ? "-critical" : ""}-$safeDate.log']);

    sys.io.File.saveContent(filename, buildCrashReport(message));
  }
  #end

  static function buildCrashReport(message:String):String {
    var fullContents:String = '=====================\n';
    fullContents += ' Funkin Crash Report\n';
    fullContents += '=====================\n\n';

    fullContents += buildSystemInfo();
    fullContents += '\n\n=====================\n\n';

    var currentState:String = 'No state loaded';
    if (FlxG.state != null) {
      var currentStateCls:Null<Class<Dynamic>> = Type.getClass(FlxG.state);
      if (currentStateCls != null) {
        currentState = Type.getClassName(currentStateCls) ?? 'No state loaded';
      }
    }

    fullContents += 'Flixel Current State: ${currentState}\n\n';
    fullContents += '=====================\n\n';
    fullContents += 'Haxelibs: \n\n';
    fullContents += '=====================\n\n';
    fullContents += 'Loaded mods: \n\n';
    fullContents += '=====================\n\n';
    fullContents += message;
    fullContents += '\n';

    return fullContents;
  }

  public static function buildSystemInfo():String {
    var fullContents = 'Generated by: Willzinhu\n';
    fullContents += 'System timestamp: ${Date.now().toString()}\n';
    var driverInfo = FlxG?.stage?.context3D?.driverInfo ?? 'N/A';
    fullContents += 'Driver info: ${driverInfo}\n';
    #if sys
    fullContents += 'Platform: ${Sys.systemName()}\n';
    #end
    fullContents += 'Render method: ${renderMethod()}\n\n';
    fullContents += '=====================\n\n';
    return fullContents;
  }

  static function generateErrorMessage(error:UncaughtErrorEvent):String {
    var errorMessage:String = "";
    var callStack:Array<haxe.CallStack.StackItem> = haxe.CallStack.exceptionStack(true);

    errorMessage += '${error.error}\n';

    for (stackItem in callStack) {
      switch (stackItem) {
        case FilePos(innerStackItem, file, line, column):
          errorMessage += '  in ${file}#${line}';
          if (column != null) errorMessage += ':${column}';
        case CFunction:
          errorMessage += '[Function] ';
        case Module(m):
          errorMessage += '[Module(${m})] ';
        case Method(classname, method):
          errorMessage += '[Function(${classname}.${method})] ';
        case LocalFunction(v):
          errorMessage += '[LocalFunction(${v})] ';
      }
      errorMessage += '\n';
    }

    return errorMessage;
  }

  public static function queryStatus():Void {
    @:privateAccess
    var currentStatus = Lib.current.stage.__uncaughtErrorEvents.__enabled;
    trace('ERROR HANDLER STATUS: ' + currentStatus);

    #if openfl_enable_handle_error
    trace('Define: openfl_enable_handle_error is enabled');
    #else
    trace('Define: openfl_enable_handle_error is disabled');
    #end

    #if openfl_disable_handle_error
    trace('Define: openfl_disable_handle_error is enabled');
    #else
    trace('Define: openfl_disable_handle_error is disabled');
    #end
  }

  public static function induceBasicCrash():Void {
    throw "This is an example of an uncaught exception.";
  }

  public static function induceNullObjectReference():Void {
    var obj:Dynamic = null;
    var value = obj.test;
  }

  public static function induceNullObjectReference2():Void {
    var obj:Dynamic = null;
    var value = obj.test();
  }

  public static function induceNullObjectReference3():Void {
    var obj:Dynamic = null;
    var value = obj();
  }

  static function renderMethod():String {
    var outputStr:String = 'UNKNOWN';
    outputStr = try {
      switch (FlxG.renderMethod) {
        case FlxRenderMethod.DRAW_TILES: 'DRAW_TILES';
        case FlxRenderMethod.BLITTING: 'BLITTING';
        default: 'UNKNOWN';
      }
    } catch (e) {
      'ERROR ON QUERY RENDER METHOD: ${e}';
    }

    return outputStr;
  }
}
