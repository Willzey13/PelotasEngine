package data;

import flixel.FlxG.FlxRenderMethod;
import flixel.FlxG;
import flixel.util.FlxSignal.FlxTypedSignal;
import openfl.Lib;
import openfl.events.UncaughtErrorEvent;
import sys.io.File;

using StringTools;

@:nullSafety
class CrashHandler {
	public static final LOG_FOLDER = 'logs';

	public static var errorSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();
	public static var criticalErrorSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

	static var hasCrashed = false;

	public static function initialize():Void {
		trace('[LOG] Enabling standard uncaught error handler...');
    openfl.Lib.current.loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, onUncaughtError);

		#if cpp
		trace('[LOG] Enabling C++ critical error handler...');
		untyped __global__.__hxcpp_set_critical_error_handler(onCriticalError);
		#end
	}

	static function onUncaughtError(error:UncaughtErrorEvent):Void {
		if (hasCrashed) return;
		hasCrashed = true;

		try {
			var message = generateErrorMessage(error);
			errorSignal.dispatch(message);

			#if sys
			logErrorMessage(message);
			#end

			displayErrorMessage(message);
		} catch (e:Dynamic) {
			trace('Error while handling crash: ' + e);
		}

		#if sys
		Sys.sleep(1);
		openfl.Lib.application.window.close();
		#end
	}

	static function onCriticalError(message:String):Void {
		if (hasCrashed) return;
		hasCrashed = true;

		try {
			criticalErrorSignal.dispatch(message);

			#if sys
			logErrorMessage(message, true);
			#end

			displayErrorMessage(message);
		} catch (e:Dynamic) {
			trace('Error while handling critical crash: $e');
		}

		#if sys
		Sys.sleep(1);
		openfl.Lib.application.window.close();
		#end
	}

	static function displayErrorMessage(message:String):Void {
		lime.app.Application.current.window.alert(message, "Fatal Uncaught Exception");
	}

	#if sys
	static function logErrorMessage(message:String, critical:Bool = false):Void {
		var logDir = haxe.io.Path.join([Sys.getCwd(), LOG_FOLDER]);
		if (!sys.FileSystem.exists(logDir)) {
			sys.FileSystem.createDirectory(logDir);
		}

		var safeDate = Date.now().toString().replace(":", "-").replace(" ", "_");
		var filename = haxe.io.Path.join([logDir, 'crash${critical ? "-critical" : ""}-$safeDate-${Std.random(10000)}.log']);

		sys.io.File.saveContent(filename, buildCrashReport(message));
	}
	#end

	static function buildCrashReport(message:String):String {
		var report = '=====================\n';
		report += ' Funkin Crash Report\n';
		report += '=====================\n\n';
		report += buildSystemInfo();
		report += '\n\n=====================\n\n';

		var currentState:String = 'No state loaded';
		if (FlxG.state != null) {
			var currentStateCls:Null<Class<Dynamic>> = Type.getClass(FlxG.state);
			if (currentStateCls != null) {
				currentState = Type.getClassName(currentStateCls);
			}
		}

		report += 'Flixel Current State: $currentState\n\n';
		report += '=====================\n\n';
		report += 'Haxelibs: (List manually if needed)\n\n';
		report += '=====================\n\n';
		report += 'Loaded mods: (List manually if needed)\n\n';
		report += '=====================\n\n';
		report += message + '\n';

		return report;
	}

	public static function buildSystemInfo():String {
		var info = 'Generated by: Willzinhu\n';
		info += 'System timestamp: ${Date.now().toString()}\n';
		info += 'Driver info: ${FlxG?.stage?.context3D?.driverInfo ?? "N/A"}\n';

		#if sys
		info += 'Platform: ${Sys.systemName()}\n';
		#if cpp
		try {
			final currentMem = cpp.vm.Gc.memInfo(cpp.vm.Gc.MEM_INFO_USAGE); // aq
			info += 'Memory usage: ${currentMem} bytes\n';
		} catch (e) {
			info += 'Memory usage: unavailable\n';
		}
		#end
		#end

		info += 'Render method: ${renderMethod()}\n';
		info += '=====================\n';
		return info;
	}

	static function generateErrorMessage(error:UncaughtErrorEvent):String {
		var msg:String = '';

		if (Std.isOfType(error.error, String)) {
			msg += 'Error (String): ${error.error}\n';
		} else if (Std.isOfType(error.error, haxe.Exception)) {
			var err:haxe.Exception = cast error.error;
			msg += 'Error: ${err.message}\nStack Trace:\n${err.stack}\n';
		} else if (error.error != null) {
			msg += 'Error (Dynamic): ${Std.string(error.error)}\n';
		} else {
			msg += 'Error: null (Unknown Exception)\n';
		}

		var callStack = haxe.CallStack.exceptionStack(true);
		if (callStack.length == 0) {
			msg += '\n[Fallback Stack Trace]\n';
			msg += haxe.CallStack.toString(haxe.CallStack.callStack());
		} else {
			msg += '\nStack Trace:\n';
			for (stackItem in callStack) {
				switch (stackItem) {
					case FilePos(_, file, line, column):
						msg += '  at $file:$line';
						if (column != null) msg += ':$column';
					case CFunction:
						msg += '  at [CFunction]';
					case Module(m):
						msg += '  at [Module: $m]';
					case Method(cls, method):
						msg += '  at $cls.$method()';
					case LocalFunction(name):
						msg += '  at local function $name';
				}
				msg += '\n';
			}
		}

		return msg;
	}

	public static function queryStatus():Void {
		@:privateAccess
		var currentStatus = Lib.current.stage.__uncaughtErrorEvents.__enabled;
		trace('ERROR HANDLER STATUS: $currentStatus');

		#if openfl_enable_handle_error
		trace('Define: openfl_enable_handle_error is ENABLED');
		#else
		trace('Define: openfl_enable_handle_error is DISABLED');
		#end

		#if openfl_disable_handle_error
		trace('Define: openfl_disable_handle_error is ENABLED');
		#else
		trace('Define: openfl_disable_handle_error is DISABLED');
		#end
	}

	// Crash examples
	public static function induceBasicCrash():Void {
		throw "This is a test crash.";
	}

	public static function induceNullObjectReference():Void {
		var obj:Dynamic = null;
		var value = obj.test;
	}

	public static function induceNullObjectReference2():Void {
		var obj:Dynamic = null;
		var value = obj.test();
	}

	public static function induceNullObjectReference3():Void {
		var obj:Dynamic = null;
		var value = obj();
	}

	static function renderMethod():String {
		return try {
			switch (FlxG.renderMethod) {
				case FlxRenderMethod.DRAW_TILES: 'DRAW_TILES';
				case FlxRenderMethod.BLITTING: 'BLITTING';
				default: 'UNKNOWN';
			}
		} catch (e) {
			'ERROR READING RENDER METHOD: $e';
		}
	}
}
